"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[848],{15973:function(e){e.exports=JSON.parse('{"functions":[{"name":"Is","desc":"Determines if the passed object is a Janitor. This checks the metatable directly.","params":[{"name":"Object","desc":"The object you are checking.","lua_type":"any"}],"returns":[{"desc":"`true` if `Object` is a Janitor.","lua_type":"boolean"}],"function_type":"static","source":{"line":41,"path":"src/init.lua"}},{"name":"Add","desc":"Adds an `Object` to Janitor for later cleanup, where `MethodName` is the key of the method within `Object` which should be called at cleanup time.\\nIf the `MethodName` is `true` the `Object` itself will be called instead. If passed an index it will occupy a namespace which can be `Remove()`d or overwritten.\\nReturns the `Object`.\\n\\n:::info\\nObjects not given an explicit `MethodName` will be passed into the `typeof` function for a very naive typecheck.\\nRBXConnections will be assigned to \\"Disconnect\\", functions will be assigned to `true`, and everything else will default to \\"Destroy\\".\\nNot recommended, but hey, you do you.\\n:::\\n\\n```lua\\nlocal Workspace = game:GetService(\\"Workspace\\")\\nlocal TweenService = game:GetService(\\"TweenService\\")\\n\\nlocal Obliterator = Janitor.new()\\nlocal Part = Workspace.Part\\n\\n-- Queue the Part to be Destroyed at Cleanup time\\nObliterator:Add(Part, \\"Destroy\\")\\n\\n-- Queue function to be called with `true` MethodName\\nObliterator:Add(print, true)\\n\\n-- This implementation allows you to specify behavior for any object\\nObliterator:Add(TweenService:Create(Part, TweenInfo.new(1), {Size = Vector3.new(1, 1, 1)}), \\"Cancel\\")\\n\\n-- By passing an Index, the Object will occupy a namespace\\n-- If \\"CurrentTween\\" already exists, it will call :Remove(\\"CurrentTween\\") before writing\\nObliterator:Add(TweenService:Create(Part, TweenInfo.new(1), {Size = Vector3.new(1, 1, 1)}), \\"Destroy\\", \\"CurrentTween\\")\\n```\\n\\n```ts\\nimport { Workspace, TweenService } from \\"@rbxts/services\\";\\nimport { Janitor } from \\"@rbxts/janitor\\";\\n\\nconst Obliterator = new Janitor<{ CurrentTween: Tween }>();\\nconst Part = Workspace.FindFirstChild(\\"Part\\") as Part;\\n\\n// Queue the Part to be Destroyed at Cleanup time\\nObliterator.Add(Part, \\"Destroy\\");\\n\\n// Queue function to be called with `true` MethodName\\nObliterator.Add(print, true);\\n\\n// This implementation allows you to specify behavior for any object\\nObliterator.Add(TweenService.Create(Part, new TweenInfo(1), {Size: new Vector3(1, 1, 1)}), \\"Cancel\\");\\n\\n// By passing an Index, the Object will occupy a namespace\\n// If \\"CurrentTween\\" already exists, it will call :Remove(\\"CurrentTween\\") before writing\\nObliterator.Add(TweenService.Create(Part, new TweenInfo(1), {Size: new Vector3(1, 1, 1)}), \\"Destroy\\", \\"CurrentTween\\");\\n```","params":[{"name":"Object","desc":"The object you want to clean up.","lua_type":"T"},{"name":"MethodName?","desc":"The name of the method that will be used to clean up. If not passed, it will first check if the object\'s type exists in TypeDefaults, and if that doesn\'t exist, it assumes `Destroy`.","lua_type":"string|true"},{"name":"Index?","desc":"The index that can be used to clean up the object manually.","lua_type":"any"}],"returns":[{"desc":"The object that was passed as the first argument.","lua_type":"T"}],"function_type":"method","source":{"line":103,"path":"src/init.lua"}},{"name":"AddPromise","desc":"Adds a [Promise](https://github.com/evaera/roblox-lua-promise) to the Janitor. If the Janitor is cleaned up and the Promise is not completed, the Promise will be cancelled.\\n\\n```lua\\nlocal Obliterator = Janitor.new()\\nObliterator:AddPromise(Promise.delay(3)):andThenCall(print, \\"Finished!\\"):catch(warn)\\ntask.wait(1)\\nObliterator:Cleanup()\\n```\\n\\n```ts\\nimport { Janitor } from \\"@rbxts/janitor\\";\\n\\nconst Obliterator = new Janitor();\\nObliterator.AddPromise(Promise.delay(3)).andThenCall(print, \\"Finished!\\").catch(warn);\\ntask.wait(1);\\nObliterator.Cleanup();\\n```","params":[{"name":"PromiseObject","desc":"The promise you want to add to the Janitor.","lua_type":"Promise"}],"returns":[{"desc":"","lua_type":"Promise"}],"function_type":"method","source":{"line":147,"path":"src/init.lua"}},{"name":"Remove","desc":"Cleans up whatever `Object` was set to this namespace by the 3rd parameter of [Janitor.Add](#Add).\\n\\n```lua\\nlocal Obliterator = Janitor.new()\\nObliterator:Add(workspace.Baseplate, \\"Destroy\\", \\"Baseplate\\")\\nObliterator:Remove(\\"Baseplate\\")\\n```\\n\\n```ts\\nimport { Workspace } from \\"@rbxts/services\\";\\nimport { Janitor } from \\"@rbxts/janitor\\";\\n\\nconst Obliterator = new Janitor<{ Baseplate: Part }>();\\nObliterator.Add(Workspace.FindFirstChild(\\"Baseplate\\") as Part, \\"Destroy\\", \\"Baseplate\\");\\nObliterator.Remove(\\"Baseplate\\");\\n```","params":[{"name":"Index","desc":"The index you want to remove.","lua_type":"any"}],"returns":[{"desc":"","lua_type":"Janitor"}],"function_type":"method","source":{"line":187,"path":"src/init.lua"}},{"name":"Get","desc":"Gets whatever object is stored with the given index, if it exists. This was added since Maid allows getting the task using `__index`.\\n\\n```lua\\nlocal Obliterator = Janitor.new()\\nObliterator:Add(workspace.Baseplate, \\"Destroy\\", \\"Baseplate\\")\\nprint(Obliterator:Get(\\"Baseplate\\")) -- Returns Baseplate.\\n```\\n\\n```ts\\nimport { Workspace } from \\"@rbxts/services\\";\\nimport { Janitor } from \\"@rbxts/janitor\\";\\n\\nconst Obliterator = new Janitor<{ Baseplate: Part }>();\\nObliterator.Add(Workspace.FindFirstChild(\\"Baseplate\\") as Part, \\"Destroy\\", \\"Baseplate\\");\\nprint(Obliterator.Get(\\"Baseplate\\")); // Returns Baseplate.\\n```","params":[{"name":"Index","desc":"The index that the object is stored under.","lua_type":"any"}],"returns":[{"desc":"This will return the object if it is found, but it won\'t return anything if it doesn\'t exist.","lua_type":"any?"}],"function_type":"method","source":{"line":237,"path":"src/init.lua"}},{"name":"Cleanup","desc":"Calls each Object\'s `MethodName` (or calls the Object if `MethodName == true`) and removes them from the Janitor. Also clears the namespace.\\nThis function is also called when you call a Janitor Object (so it can be used as a destructor callback).\\n\\n```lua\\nObliterator:Cleanup() -- Valid.\\nObliterator() -- Also valid.\\n```\\n\\n```ts\\nObliterator.Cleanup()\\n```","params":[],"returns":[],"function_type":"method","source":{"line":259,"path":"src/init.lua"}},{"name":"Destroy","desc":"Calls [Janitor.Cleanup](#Cleanup) and renders the Janitor unusable.\\n\\n:::warning\\nRunning this will make any attempts to call a function of Janitor error.\\n:::","params":[],"returns":[],"function_type":"method","source":{"line":296,"path":"src/init.lua"}},{"name":"LinkToInstance","desc":"\\"Links\\" this Janitor to an Instance, such that the Janitor will `Cleanup` when the Instance is `Destroyed()` and garbage collected.\\nA Janitor may only be linked to one instance at a time, unless `AllowMultiple` is true. When called with a truthy `AllowMultiple` parameter,\\nthe Janitor will \\"link\\" the Instance without overwriting any previous links, and will also not be overwritable.\\nWhen called with a falsy `AllowMultiple` parameter, the Janitor will overwrite the previous link which was also called with a falsy `AllowMultiple` parameter, if applicable.\\n\\n```lua\\nlocal Obliterator = Janitor.new()\\n\\nObliterator:Add(function()\\n\\tprint(\\"Cleaning up!\\")\\nend, true)\\n\\ndo\\n\\tlocal Folder = Instance.new(\\"Folder\\")\\n\\tObliterator:LinkToInstance(Folder)\\n\\tFolder:Destroy()\\nend\\n```\\n\\n```ts\\nimport { Janitor } from \\"@rbxts/janitor\\";\\n\\nconst Obliterator = new Janitor();\\nObliterator.Add(() => print(\\"Cleaning up!\\"), true);\\n\\n{\\n\\tconst Folder = new Instance(\\"Folder\\");\\n\\tObliterator.LinkToInstance(Folder, false);\\n\\tFolder.Destroy();\\n}\\n```\\n\\nThis returns a mock `RBXScriptConnection` (see: [RbxScriptConnection](#RbxScriptConnection)).","params":[{"name":"Object","desc":"The instance you want to link the Janitor to.","lua_type":"Instance"},{"name":"AllowMultiple?","desc":"Whether or not to allow multiple links on the same Janitor.","lua_type":"boolean"}],"returns":[{"desc":"A pseudo RBXScriptConnection that can be disconnected to prevent the cleanup of LinkToInstance.","lua_type":"RbxScriptConnection"}],"function_type":"method","source":{"line":372,"path":"src/init.lua"}},{"name":"LinkToInstances","desc":"Links several instances to a new Janitor, which is then returned.","params":[{"name":"...","desc":"All the Instances you want linked.","lua_type":"Instance"}],"returns":[{"desc":"A new Janitor that can be used to manually disconnect all LinkToInstances.","lua_type":"Janitor"}],"function_type":"method","source":{"line":420,"path":"src/init.lua"}},{"name":"new","desc":"Instantiates a new Janitor object.","params":[],"returns":[{"desc":"","lua_type":"Janitor"}],"function_type":"static","source":{"line":433,"path":"src/init.lua"}}],"properties":[],"types":[],"name":"Janitor","desc":"Janitor is a light-weight, flexible object for cleaning up connections, instances, or anything. This implementation covers all use cases,\\nas it doesn\'t force you to rely on naive typechecking to guess how an instance should be cleaned up.\\nInstead, the developer may specify any behavior for any object.","source":{"line":24,"path":"src/init.lua"}}')}}]);