[{"title":"Getting Started with Janitor","type":0,"sectionRef":"#","url":"/Janitor/docs/intro","content":"Getting Started with Janitor Here are some quick links to get started using Janitor: Installation guideAPI DocsWhy use Janitor?Who uses Janitor?","keywords":""},{"title":"Who uses Janitor?","type":0,"sectionRef":"#","url":"/Janitor/docs/who-uses-janitor","content":"Who uses Janitor? Several games both big and small use Janitor as well as many plugins. Armtastic by Mullets Mafia RedBe an Alien: Renewal by PeZsmisticBenchmarker by boatbomberBloopville (NOT RELEASED) by BloopVille TeamRBLX04 by movsbRepoToRoblox by boatbomberScience Simulator by Interbyte StudioStudio Tweaks by PeZsmisticTropical Town Tycoon by Mightybull Games If you want your project featured here, leave a pull request! Make sure to change this file as well.","keywords":""},{"title":"Installation","type":0,"sectionRef":"#","url":"/Janitor/docs/Installation","content":"","keywords":""},{"title":"Method #1 - RepoToRoblox​","type":1,"pageTitle":"Installation","url":"/Janitor/docs/Installation#method-1---repotoroblox","content":"Using Boatbomber's RepoToRoblox plugin is the easiest way to install in Studio. In the RepoToRoblox widget, enter howmanysmall as the Owner and Janitor as the Repo.Click the Clone Repo button.  "},{"title":"Method #2 - HttpService​","type":1,"pageTitle":"Installation","url":"/Janitor/docs/Installation#method-2---httpservice","content":"This method uses HttpService to install Janitor. In Roblox Studio, paste the following command into your command bar.Run the following command: local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local HttpService = game:GetService(&quot;HttpService&quot;) local HttpEnabled = HttpService.HttpEnabled HttpService.HttpEnabled = true local function RequestAsync(RequestDictionary) return HttpService:RequestAsync(RequestDictionary) end local function GetAsync(Url, Headers) Headers[&quot;cache-control&quot;] = &quot;no-cache&quot; local Success, ResponseDictionary = pcall(RequestAsync, { Headers = Headers; Method = &quot;GET&quot;; Url = Url; }) if Success then if ResponseDictionary.Success then return ResponseDictionary.Body else return false, string.format(&quot;HTTP %*: %*&quot;, ResponseDictionary.StatusCode, ResponseDictionary.StatusMessage) end else return false, ResponseDictionary end end local function Initify(Root) local InitFile = Root:FindFirstChild(&quot;init&quot;) or Root:FindFirstChild(&quot;init.luau&quot;) or Root:FindFirstChild(&quot;init.client.luau&quot;) or Root:FindFirstChild(&quot;init.server.luau&quot;) or Root:FindFirstChild(&quot;init.luau&quot;) or Root:FindFirstChild(&quot;init.client.luau&quot;) or Root:FindFirstChild(&quot;init.server.lua&quot;) if InitFile then InitFile.Name = Root.Name InitFile.Parent = Root.Parent for _, Child in Root:GetChildren() do Child.Parent = InitFile end Root:Destroy() Root = InitFile end for _, Child in Root:GetChildren() do Initify(Child) end return Root end local FilesList = HttpService:JSONDecode(assert(GetAsync( &quot;https://api.github.com/repos/howmanysmall/Janitor/contents/src&quot;, {accept = &quot;application/vnd.github.v3+json&quot;} ))) local Janitor = Instance.new(&quot;Folder&quot;) Janitor.Name = &quot;Janitor&quot; for _, FileData in FilesList do local ModuleScript = Instance.new(&quot;ModuleScript&quot;) ModuleScript.Name = tostring(string.match(FileData.name, &quot;(%w+)%.luau?&quot;)) local Success, Source = GetAsync(FileData.download_url, {}) if not Success then ModuleScript.Source = string.format(&quot;-- %*&quot;, tostring(Source)) else ModuleScript.Source = tostring(Success) end ModuleScript.Parent = Janitor end Janitor.Parent = ReplicatedStorage Initify(Janitor) HttpService.HttpEnabled = HttpEnabled "},{"title":"Method 3 - Manual​","type":1,"pageTitle":"Installation","url":"/Janitor/docs/Installation#method-3---manual","content":"Visit the latest releaseUnder Assets, click Janitor.rbxm Using Rojo? Put the file into your game directly.Using Roblox Studio? Drag the file onto the viewport. It should insert under Workspace. "},{"title":"Method 4 - Wally​","type":1,"pageTitle":"Installation","url":"/Janitor/docs/Installation#method-4---wally","content":"Setup Wally by using wally init.Add howmanysmall/Janitor as a dependency. [dependencies] Janitor = &quot;howmanysmall/janitor@^1.17.0&quot;  "},{"title":"Next​","type":1,"pageTitle":"Installation","url":"/Janitor/docs/Installation#next","content":"Now, check out the API reference! "},{"title":"Why use Janitor?","type":0,"sectionRef":"#","url":"/Janitor/docs/why-use-janitor","content":"","keywords":""},{"title":"Ease of use​","type":1,"pageTitle":"Why use Janitor?","url":"/Janitor/docs/why-use-janitor#ease-of-use","content":"Janitor makes dealing with garbage collection much less annoying and stressful because it manages them all in a nice interface. "},{"title":"High Performance​","type":1,"pageTitle":"Why use Janitor?","url":"/Janitor/docs/why-use-janitor#high-performance","content":"While I don't really recommend using Janitor if you're gonna be cleaning up every frame, it is significantly faster than any other library with a similar API design. "},{"title":"Returning​","type":1,"pageTitle":"Why use Janitor?","url":"/Janitor/docs/why-use-janitor#returning","content":"Janitor:Add() returns the first object passed, which Maid does not. "},{"title":"Custom Cleanup Methods​","type":1,"pageTitle":"Why use Janitor?","url":"/Janitor/docs/why-use-janitor#custom-cleanup-methods","content":"With Maid, you can't tell it to do anything other than :Destroy(), :Disconnect(), or call something. Janitor allows any method you choose to be called for cleanup. This includes Tween:Stop(), Humanoid:BreakJoints(), or Tool:Deactivate(). You can see this being used in the Janitor:AddPromise() method. "},{"title":"API Consistency​","type":1,"pageTitle":"Why use Janitor?","url":"/Janitor/docs/why-use-janitor#api-consistency","content":"Janitor:Add() also accepts a custom reference to store under, which keeps the API more consistent. \tJanitor\tMaid\tTroveAdding an Instance\tJanitor:Add(Instance)\tMaid:GiveTask(Instance)\tTrove:Add(Instance) Adding an Instance with a given index\tJanitor:Add(Instance, false, &quot;Index&quot;)\tMaid.Index = Instance\tCAN NOT DO THIS Adding an Instance with a cleanup method\tJanitor:Add(Tween, &quot;Cancel&quot;)\tCAN NOT DO THIS\tTrove:Add(Tween, &quot;Cancel&quot;) Removing an Instance\tJanitor:Remove(&quot;Index&quot;)\tMaid.Index = nil\tCAN NOT DO THIS Removing without cleanup\tJanitor:RemoveNoClean(&quot;Index&quot;)\tCAN NOT DO THIS\tCAN NOT DO THIS "},{"title":"LinkToInstance​","type":1,"pageTitle":"Why use Janitor?","url":"/Janitor/docs/why-use-janitor#linktoinstance","content":"Janitor also allows linking to an Instance via the Janitor:LinkToInstance() method. This allows the Janitor to cleanup everything added to it when an Instance has its Instance:Destroy() method invoked. "},{"title":"Native support for Promises​","type":1,"pageTitle":"Why use Janitor?","url":"/Janitor/docs/why-use-janitor#native-support-for-promises","content":"Janitor is the only library of its kind that supports cancelling Promises. "},{"title":"TypeScript Support​","type":1,"pageTitle":"Why use Janitor?","url":"/Janitor/docs/why-use-janitor#typescript-support","content":"Janitor has the best TypeScript support of any library like it. You have full intellisense with the objects stored in it, as well as the methods you can use to cleanup with. "},{"title":"Janitor","type":0,"sectionRef":"#","url":"/Janitor/api/Janitor","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Janitor","url":"/Janitor/api/Janitor#properties","content":" "},{"title":"CurrentlyCleaning​","type":1,"pageTitle":"Janitor","url":"/Janitor/api/Janitor#CurrentlyCleaning","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Janitor.CurrentlyCleaning: boolean Whether or not the Janitor is currently cleaning up.  "},{"title":"SuppressInstanceReDestroy​","type":1,"pageTitle":"Janitor","url":"/Janitor/api/Janitor#SuppressInstanceReDestroy","content":"since 1.15.4 &lt;/&gt; Janitor.SuppressInstanceReDestroy: boolean Whether or not you want to suppress the re-destroying of instances. Default is false, which is the original behavior. "},{"title":"Functions​","type":1,"pageTitle":"Janitor","url":"/Janitor/api/Janitor#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Janitor","url":"/Janitor/api/Janitor#new","content":"&lt;/&gt; Janitor.new() → Janitor Instantiates a new Janitor object.  "},{"title":"Is​","type":1,"pageTitle":"Janitor","url":"/Janitor/api/Janitor#Is","content":"&lt;/&gt; Janitor.Is( object: unknown-- The object you are checking. ) → boolean-- true if object is a Janitor. Determines if the passed object is a Janitor. This checks the metatable directly.  "},{"title":"instanceof​","type":1,"pageTitle":"Janitor","url":"/Janitor/api/Janitor#instanceof","content":"&lt;/&gt; Janitor.instanceof( object: unknown-- The object you are checking. ) → boolean-- true if object is a Janitor. An alias for Janitor.Is. This is intended for roblox-ts support.  "},{"title":"Add​","type":1,"pageTitle":"Janitor","url":"/Janitor/api/Janitor#Add","content":"&lt;/&gt; Janitor:Add( object: T,-- The object you want to clean up. methodName?: boolean | string,-- The name of the method that will be used to clean up. If not passed, it will first check if the object's type exists in TypeDefaults, and if that doesn't exist, it assumes Destroy. index?: unknown-- The index that can be used to clean up the object manually. ) → T-- The object that was passed as the first argument. Adds an object to Janitor for later cleanup, where methodName is the key of the method within object which should be called at cleanup time. If the methodName is true the object itself will be called if it's a function or have task.cancel called on it if it is a thread. If passed an index it will occupy a namespace which can be Remove()d or overwritten. Returns the object. Note Objects not given an explicit methodName will be passed into the typeof function for a very naive typecheck. RBXConnections will be assigned to &quot;Disconnect&quot;, functions and threads will be assigned to true, and everything else will default to &quot;Destroy&quot;. Not recommended, but hey, you do you. Luau: local Workspace = game:GetService(&quot;Workspace&quot;) local TweenService = game:GetService(&quot;TweenService&quot;) local obliterator = Janitor.new() local part = Workspace:FindFirstChild(&quot;Part&quot;) :: Part -- Queue the Part to be Destroyed at Cleanup time obliterator:Add(part, &quot;Destroy&quot;) -- Queue function to be called with `true` methodName obliterator:Add(print, true) -- Close a thread. obliterator:Add(task.defer(function() while true do print(&quot;Running!&quot;) task.wait(0.5) end end), true) -- This implementation allows you to specify behavior for any object obliterator:Add(TweenService:Create(part, TweenInfo.new(1), {Size = Vector3.one}), &quot;Cancel&quot;) -- By passing an index, the object will occupy a namespace -- If &quot;CurrentTween&quot; already exists, it will call :Remove(&quot;CurrentTween&quot;) before writing obliterator:Add(TweenService:Create(part, TweenInfo.new(1), {Size = Vector3.one}), &quot;Destroy&quot;, &quot;CurrentTween&quot;) TypeScript: import { Workspace, TweenService } from &quot;@rbxts/services&quot;; import { Janitor } from &quot;@rbxts/janitor&quot;; const obliterator = new Janitor&lt;{ CurrentTween: Tween }&gt;(); const part = Workspace.FindFirstChild(&quot;Part&quot;) as Part; // Queue the part to be Destroyed at Cleanup time obliterator.Add(part, &quot;Destroy&quot;); // Queue function to be called with `true` methodName obliterator.Add(print, true); // Close a thread. obliterator.Add(task.defer(() =&gt; { while (true) { print(&quot;Running!&quot;); task.wait(0.5); } }), true); // This implementation allows you to specify behavior for any object obliterator.Add(TweenService.Create(part, new TweenInfo(1), { Size: Vector3.one }), &quot;Cancel&quot;); // By passing an index, the object will occupy a namespace // If &quot;CurrentTween&quot; already exists, it will call :Remove(&quot;CurrentTween&quot;) before writing obliterator.Add(TweenService.Create(part, new TweenInfo(1), { Size: Vector3.one }), &quot;Destroy&quot;, &quot;CurrentTween&quot;);   "},{"title":"AddObject​","type":1,"pageTitle":"Janitor","url":"/Janitor/api/Janitor#AddObject","content":"since v1.16.0 &lt;/&gt; Janitor:AddObject( constructor: {new: (A...) → T},-- The constructor for the object you want to add to the Janitor. methodName?: boolean | string,-- The name of the method that will be used to clean up. If not passed, it will first check if the object's type exists in TypeDefaults, and if that doesn't exist, it assumes Destroy. index?: unknown,-- The index that can be used to clean up the object manually. ...: A...-- The arguments that will be passed to the constructor. ) → T-- The object that was passed as the first argument. Constructs an object for you and adds it to the Janitor. It's really just shorthand for Janitor:Add(object.new(), methodName, index). Luau: local obliterator = Janitor.new() local subObliterator = obliterator:AddObject(Janitor, &quot;Destroy&quot;) -- subObliterator is another Janitor! TypeScript: import { Janitor } from &quot;@rbxts/janitor&quot;; const obliterator = new Janitor(); const subObliterator = obliterator.AddObject(Janitor, &quot;Destroy&quot;);   "},{"title":"AddPromise​","type":1,"pageTitle":"Janitor","url":"/Janitor/api/Janitor#AddPromise","content":"&lt;/&gt; Janitor:AddPromise( promiseObject: Promise-- The promise you want to add to the Janitor. ) → Promise Adds a Promise to the Janitor. If the Janitor is cleaned up and the Promise is not completed, the Promise will be cancelled. Luau: local obliterator = Janitor.new() obliterator:AddPromise(Promise.delay(3)):andThenCall(print, &quot;Finished!&quot;):catch(warn) task.wait(1) obliterator:Cleanup() TypeScript: import { Janitor } from &quot;@rbxts/janitor&quot;; const obliterator = new Janitor(); obliterator.AddPromise(Promise.delay(3)).andThenCall(print, &quot;Finished!&quot;).catch(warn); task.wait(1); obliterator.Cleanup();  "},{"title":"Errors","type":1,"pageTitle":"Janitor","url":"/Janitor/api/Janitor##","content":"Type\tDescriptionNotAPromiseError\tThrown if the promise is not a Promise.  "},{"title":"Remove​","type":1,"pageTitle":"Janitor","url":"/Janitor/api/Janitor#Remove","content":"&lt;/&gt; Janitor:Remove( index: unknown-- The index you want to remove. ) → Janitor Cleans up whatever Object was set to this namespace by the 3rd parameter of Janitor.Add. Luau: local obliterator = Janitor.new() obliterator:Add(workspace.Baseplate, &quot;Destroy&quot;, &quot;Baseplate&quot;) obliterator:Remove(&quot;Baseplate&quot;) TypeScript: import { Workspace } from &quot;@rbxts/services&quot;; import { Janitor } from &quot;@rbxts/janitor&quot;; const obliterator = new Janitor&lt;{ Baseplate: Part }&gt;(); obliterator.Add(Workspace.FindFirstChild(&quot;Baseplate&quot;) as Part, &quot;Destroy&quot;, &quot;Baseplate&quot;); obliterator.Remove(&quot;Baseplate&quot;);   "},{"title":"RemoveNoClean​","type":1,"pageTitle":"Janitor","url":"/Janitor/api/Janitor#RemoveNoClean","content":"since v1.15.0 &lt;/&gt; Janitor:RemoveNoClean( index: unknown-- The index you are removing. ) → Janitor Removes an object from the Janitor without running a cleanup. Luau local obliterator = Janitor.new() obliterator:Add(function() print(&quot;Removed!&quot;) end, true, &quot;Function&quot;) obliterator:RemoveNoClean(&quot;Function&quot;) -- Does not print. TypeScript: import { Janitor } from &quot;@rbxts/janitor&quot;; const obliterator = new Janitor&lt;{ Function: () =&gt; void }&gt;(); obliterator.Add(() =&gt; print(&quot;Removed!&quot;), true, &quot;Function&quot;); obliterator.RemoveNoClean(&quot;Function&quot;); // Does not print.   "},{"title":"RemoveList​","type":1,"pageTitle":"Janitor","url":"/Janitor/api/Janitor#RemoveList","content":"since v1.14.0 &lt;/&gt; Janitor:RemoveList( ...: unknown-- The indices you want to remove. ) → Janitor Cleans up multiple objects at once. Luau: local obliterator = Janitor.new() obliterator:Add(function() print(&quot;Removed One&quot;) end, true, &quot;One&quot;) obliterator:Add(function() print(&quot;Removed Two&quot;) end, true, &quot;Two&quot;) obliterator:Add(function() print(&quot;Removed Three&quot;) end, true, &quot;Three&quot;) obliterator:RemoveList(&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;) -- Prints &quot;Removed One&quot;, &quot;Removed Two&quot;, and &quot;Removed Three&quot; TypeScript: import { Janitor } from &quot;@rbxts/janitor&quot;; type NoOp = () =&gt; void const obliterator = new Janitor&lt;{ One: NoOp, Two: NoOp, Three: NoOp }&gt;(); obliterator.Add(() =&gt; print(&quot;Removed One&quot;), true, &quot;One&quot;); obliterator.Add(() =&gt; print(&quot;Removed Two&quot;), true, &quot;Two&quot;); obliterator.Add(() =&gt; print(&quot;Removed Three&quot;), true, &quot;Three&quot;); obliterator.RemoveList(&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;); // Prints &quot;Removed One&quot;, &quot;Removed Two&quot;, and &quot;Removed Three&quot;   "},{"title":"RemoveListNoClean​","type":1,"pageTitle":"Janitor","url":"/Janitor/api/Janitor#RemoveListNoClean","content":"since v1.15.0 &lt;/&gt; Janitor:RemoveListNoClean( ...: unknown-- The indices you want to remove. ) → Janitor Cleans up multiple objects at once without running their cleanup. Luau: local obliterator = Janitor.new() obliterator:Add(function() print(&quot;Removed One&quot;) end, true, &quot;One&quot;) obliterator:Add(function() print(&quot;Removed Two&quot;) end, true, &quot;Two&quot;) obliterator:Add(function() print(&quot;Removed Three&quot;) end, true, &quot;Three&quot;) obliterator:RemoveListNoClean(&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;) -- Nothing is printed. TypeScript: import { Janitor } from &quot;@rbxts/janitor&quot;; type NoOperation = () =&gt; void const obliterator = new Janitor&lt;{ One: NoOperation, Two: NoOperation, Three: NoOperation }&gt;(); obliterator.Add(() =&gt; print(&quot;Removed One&quot;), true, &quot;One&quot;); obliterator.Add(() =&gt; print(&quot;Removed Two&quot;), true, &quot;Two&quot;); obliterator.Add(() =&gt; print(&quot;Removed Three&quot;), true, &quot;Three&quot;); obliterator.RemoveListNoClean(&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;); // Nothing is printed.   "},{"title":"Get​","type":1,"pageTitle":"Janitor","url":"/Janitor/api/Janitor#Get","content":"&lt;/&gt; Janitor:Get( index: unknown-- The index that the object is stored under. ) → unknown?-- This will return the object if it is found, but it won't return anything if it doesn't exist. Gets whatever object is stored with the given index, if it exists. This was added since Maid allows getting the task using __index. Luau: local obliterator = Janitor.new() obliterator:Add(Workspace.Baseplate, &quot;Destroy&quot;, &quot;Baseplate&quot;) print(obliterator:Get(&quot;Baseplate&quot;)) -- Returns Baseplate. TypeScript: import { Workspace } from &quot;@rbxts/services&quot;; import { Janitor } from &quot;@rbxts/janitor&quot;; const obliterator = new Janitor&lt;{ Baseplate: Part }&gt;(); obliterator.Add(Workspace.FindFirstChild(&quot;Baseplate&quot;) as Part, &quot;Destroy&quot;, &quot;Baseplate&quot;); print(obliterator.Get(&quot;Baseplate&quot;)); // Returns Baseplate.   "},{"title":"GetAll​","type":1,"pageTitle":"Janitor","url":"/Janitor/api/Janitor#GetAll","content":"since v1.15.1 &lt;/&gt; Janitor:GetAll() → {[any]: any} Returns a frozen copy of the Janitor's indices. Luau: local obliterator = Janitor.new() obliterator:Add(Workspace.Baseplate, &quot;Destroy&quot;, &quot;Baseplate&quot;) print(obliterator:GetAll().Baseplate) -- Prints Baseplate. TypeScript: import { Workspace } from &quot;@rbxts/services&quot;; import { Janitor } from &quot;@rbxts/janitor&quot;; const obliterator = new Janitor&lt;{ Baseplate: Part }&gt;(); obliterator.Add(Workspace.FindFirstChild(&quot;Baseplate&quot;) as Part, &quot;Destroy&quot;, &quot;Baseplate&quot;); print(obliterator.GetAll().Baseplate); // Prints Baseplate.   "},{"title":"Cleanup​","type":1,"pageTitle":"Janitor","url":"/Janitor/api/Janitor#Cleanup","content":"&lt;/&gt; Janitor:Cleanup() → () Calls each object's methodName (or calls the object if methodName == true) and removes them from the Janitor. Also clears the namespace. This function is also called when you call a Janitor object (so it can be used as a destructor callback). Luau: obliterator:Cleanup() -- Valid. obliterator() -- Also valid. TypeScript: obliterator.Cleanup() // TypeScript version doesn't support the __call method of cleaning.   "},{"title":"Destroy​","type":1,"pageTitle":"Janitor","url":"/Janitor/api/Janitor#Destroy","content":"&lt;/&gt; Janitor:Destroy() → () Calls Janitor.Cleanup and renders the Janitor unusable. Metatable Removal Running this will make any further attempts to call a method of Janitor error.  "},{"title":"LinkToInstance​","type":1,"pageTitle":"Janitor","url":"/Janitor/api/Janitor#LinkToInstance","content":"&lt;/&gt; Janitor:LinkToInstance( object: Instance ,-- The instance you want to link the Janitor to. allowMultiple?: boolean-- Whether or not to allow multiple links on the same Janitor. ) → RBXScriptConnection -- A RBXScriptConnection that can be disconnected to prevent the cleanup of LinkToInstance. &quot;Links&quot; this Janitor to an Instance, such that the Janitor will Cleanup when the Instance is Destroy()d and garbage collected. A Janitor may only be linked to one instance at a time, unless allowMultiple is true. When called with a truthy allowMultiple parameter, the Janitor will &quot;link&quot; the Instance without overwriting any previous links, and will also not be overwritable. When called with a falsy allowMultiple parameter, the Janitor will overwrite the previous link which was also called with a falsy allowMultiple parameter, if applicable. Luau: local obliterator = Janitor.new() obliterator:Add(function() print(&quot;Cleaning up!&quot;) end, true) do local folder = Instance.new(&quot;Folder&quot;) obliterator:LinkToInstance(folder) folder:Destroy() end TypeScript: import { Janitor } from &quot;@rbxts/janitor&quot;; const obliterator = new Janitor(); obliterator.Add(() =&gt; print(&quot;Cleaning up!&quot;), true); { const folder = new Instance(&quot;Folder&quot;); obliterator.LinkToInstance(folder, false); folder.Destroy(); }   "},{"title":"LinkToInstances​","type":1,"pageTitle":"Janitor","url":"/Janitor/api/Janitor#LinkToInstances","content":"&lt;/&gt; Janitor:LinkToInstances( ...: Instance -- All the Instances you want linked. ) → Janitor-- A new Janitor that can be used to manually disconnect all LinkToInstances. Links several instances to a new Janitor, which is then returned. "}]